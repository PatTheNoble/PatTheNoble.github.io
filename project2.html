<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Manager</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
</head>
<body>
    <nav>
        <div class="container">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="index.html#about">About</a></li>
                <li><a href="index.html#projects">Projects</a></li>
                <li><a href="index.html#contact">Contact</a></li>
            </ul>
        </div>
    </nav>
    
    <header class="header-container">
        <img src="images/unit_manager/unit_manager_5.webp" alt="Banner Image" class="image-banner">
        <div class="header-content">
            <h1>Unit Manager</h1>
            <p>An efficient system for handling complex game AI in Unreal Engine 5</p>
        </div>
    </header>

    <section class="project-details container">
        <h2>Technologies Used</h2>
        <ul>
            <li>C++</li>
            <li>Unreal Engine 5</li>
        </ul>

        <h3>Problem: Unreal Engine’s AI and Movement Components Are Expensive</h3>
        <p>
            Unreal Engine’s default character and movement components are designed for high-quality player interactions, but they come with a high computational cost. 
            In our case, the system could only handle about 10 characters simultaneously on low end devices. 
            This was a significant limitation, as our game wanted to support 100+ AI enemies interacting in real-time.
        </p>

        <h3>Solution: Custom Unit Manager</h3>
        <p>
            To address this, we developed a custom Unit Manager designed to efficiently handle a large number of AI entities. 
            By optimizing how AI behavior is managed and offloading expensive calculations, we vastly increased the system’s capacity, allowing the game to manage over 100 AI enemies at once with minimal impact on performance.
        </p>

        <h3>Multithreading and Tick Aggregation</h3>
        <p> Optimizations include: </p>
        <ul>
            <li> Offloading units from the game thread when they are not gameplay relevant </li>
            <li> Handling every unit's behavior from a single system's tick to reduce overhead </li>
        </ul>

        <h3>Avoidance Algorithm</h3>
        <!-- <li> Movement uses a single line trace.</li>
        <li> 
            Avoidance is handled using a custom grid system. 
            Units only avoid other units in the same grid to avoid n^2 cost of avoiding every other unit.
            World location is converted into a key to access the current cell of the unit.
        </li> -->
        <li> 
            Problem: The cost of Avoidance is n^2 as all units must avoid eachother
        </li>
        <li>
            To optimize this we used a 3D array "grid" to partition the units into smaller groups based on their location
        </li>
        <li>
            Each index in the 3D array represents a world location range, to convert the unit location to a grid cell we divide their location by the cell size
        </li>        
        <li>
            Units only avoid other units in the same grid cell, greatly reducing the exponential cost of avoidance
        </li>

        <img src="images/unit_manager/unit_manager_2.webp" alt="Avoidance Gif" class="responsive-img" loading="lazy">

        <br/>
        <a href="index.html#projects" class="btn">Back to Portfolio</a>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2024 Patrick Morris. All Rights Reserved.</p>
        </div>
    </footer>
</body>
</html>
